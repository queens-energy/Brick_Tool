<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Universal TTL ‚Üí Building UI</title>
  <style>
    :root { --bg1:#667eea; --bg2:#764ba2; --ink:#2c3e50; --muted:#6c757d; --brand:#4a90e2; --card:#ffffff; }
    html,body{height:100%}
    body{margin:0;padding:20px;box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";background:linear-gradient(135deg,var(--bg1) 0%,var(--bg2) 100%);color:var(--ink)}
    .container{max-width:1200px;margin:0 auto;background:rgba(255,255,255,.96);border-radius:16px;padding:24px;box-shadow:0 20px 40px rgba(0,0,0,.12)}
    h1{margin:0 0 8px;font-size:28px}
    .subtitle{color:var(--muted);margin-bottom:18px}
    .uploader{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .uploader input[type=file]{display:none}
    .btn{appearance:none;border:0;border-radius:10px;padding:10px 14px;background:var(--brand);color:#fff;font-weight:600;cursor:pointer;box-shadow:0 6px 14px rgba(74,144,226,.25)}
    .btn.secondary{background:#6c757d}
    .badge{display:inline-block;background:rgba(74,144,226,.12);color:var(--brand);padding:4px 10px;border-radius:999px;font-size:12px;font-weight:600}

    /* Low‚Äëkey pill toggle for Diagram view */
    .view-toggle{display:flex;align-items:center;gap:10px;padding:6px 10px;border:1px solid #d8e0f2;border-radius:999px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.04)}
    .view-toggle .label{font-weight:600;color:#405a7f}
    .view-toggle input{appearance:none;width:38px;height:22px;border-radius:999px;background:#e9edf7;position:relative;outline:none;cursor:pointer;transition:background .2s}
    .view-toggle input::after{content:"";position:absolute;top:3px;left:3px;width:16px;height:16px;border-radius:50%;background:#fff;box-shadow:0 1px 3px rgba(0,0,0,.2);transition:left .2s}
    .view-toggle input:checked{background:var(--brand)}
    .view-toggle input:checked::after{left:19px}

    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    .spacer{flex:1}
    .breadcrumb{background:#f8f9fa;padding:12px 16px;border-radius:10px;margin:16px 0 10px;border-left:4px solid var(--brand)}
    .breadcrumb-item{display:inline-block;color:var(--brand);cursor:pointer;font-weight:600}
    .breadcrumb-item:hover{text-decoration:underline}
    .breadcrumb-separator{margin:0 8px;color:var(--muted)}

    .statsbar{margin:6px 0 16px;display:inline-block}
    .section-title{font-weight:800;margin-top:8px;margin-bottom:4px;color:#263238}
    .current-level{font-size:20px;font-weight:800;text-align:center;margin:6px 0 6px}

    .items-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:16px;margin-top:10px}
    .item-card{border:2px solid #e9ecef;border-radius:12px;padding:16px;background:linear-gradient(135deg,#fff 0%,#f8f9fa 100%);cursor:pointer;position:relative;transition:transform .2s,box-shadow .2s,border-color .2s}
    .item-card:hover{transform:translateY(-4px);box-shadow:0 10px 22px rgba(0,0,0,.12);border-color:var(--brand)}
    .item-title{font-size:18px;font-weight:800;margin-bottom:8px}
    .item-type{margin-bottom:10px}
    .item-details{color:var(--muted);font-size:14px;line-height:1.5}
    .item-count{position:absolute;top:12px;right:12px;background:var(--brand);color:#fff;width:30px;height:30px;display:grid;place-items:center;font-weight:800;border-radius:999px;font-size:13px}

    .tag-campus{border-left:6px solid #e74c3c;background:linear-gradient(135deg,#fff5f5 0%,#ffeaea 100%)}
    .tag-building{border-left:6px solid #f39c12;background:linear-gradient(135deg,#fffbef 0%,#fff4d6 100%)}
    .tag-space{border-left:6px solid #27ae60;background:linear-gradient(135deg,#f1fff4 0%,#ddf6e6 100%)}
    .tag-system{border-left:6px solid #8e44ad;background:linear-gradient(135deg,#f8f0ff 0%,#ecdcff 100%)}
    .tag-equipment{border-left:6px solid #3498db;background:linear-gradient(135deg,#f0f8ff 0%,#d9ecff 100%)}
    .tag-loose{border-left:6px solid #17a2b8;background:linear-gradient(135deg,#f0feff 0%,#e1f7fa 100%)}
    .tag-point{border-left:6px solid #ff6b35;background:linear-gradient(135deg,#fff8f5 0%,#ffe8df 100%)}


    .no-items{text-align:center;color:var(--muted);font-style:italic;padding:32px;background:#f8f9fa;border-radius:10px;margin-top:10px}
    .muted{color:var(--muted)}
    .tiny{font-size:12px}
    .back-button{background:#6c757d;color:#fff;border:none;padding:10px 16px;border-radius:8px;cursor:pointer;font-weight:600}
    .location-info{background:#e8f4fd;border:1px solid #bee5eb;border-radius:8px;padding:10px 12px;margin-top:10px;font-size:13px;color:#0c5460}
    .hidden{display:none}
    details{background:#f8f9fa;padding:10px 12px;border-radius:10px}
    summary{cursor:pointer}

    /* Diagram styles */
    .diagram{display:flex;flex-direction:column;align-items:stretch;gap:20px}
    .level{display:flex;justify-content:center;align-items:flex-start;width:100%;flex-wrap:wrap;gap:15px}
    .node{background:#fff;border:3px solid;border-radius:10px;padding:10px 15px;text-align:center;box-shadow:0 3px 10px rgba(0,0,0,.1);transition:transform .2s;min-width:120px;position:relative;margin:5px;cursor:pointer}
    .node:hover{transform:translateY(-3px);z-index:10}
    .node-title{font-weight:800;font-size:.96em;margin-bottom:3px}
    .node-type{font-size:.7em;color:#666;font-style:italic;margin-bottom:3px}
    .node-location{font-size:.7em;color:#555;margin-top:3px;padding:1px 6px;background:rgba(0,0,0,.05);border-radius:8px;display:inline-block}
    .connection-line{width:2px;background:linear-gradient(to bottom,#ccc,#999);height:20px;margin:0 auto}
    .building-group{display:flex;flex-direction:column;align-items:center;gap:10px;margin:4px 10px;border:1px dashed #ccc;border-radius:10px;padding:15px;background:rgba(76,175,80,.05)}
    .rooms-row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}
    .systems-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px;margin-top:10px;width:100%;grid-auto-flow:row dense}
    .equipment-row{display:flex;gap:12px;flex-wrap:wrap;justify-content:center}
    .points-row{display:flex;gap:8px;flex-wrap:wrap;justify-content:center}

    /* Color-code nodes like cards */
    .node.campus{border-color:#e74c3c;background:linear-gradient(135deg,#fff5f5 0%,#ffeaea 100%)}
    .node.building{border-color:#f39c12;background:linear-gradient(135deg,#fffbef 0%,#fff4d6 100%)}
    .node.room{border-color:#27ae60;background:linear-gradient(135deg,#f1fff4 0%,#ddf6e6 100%)}
    .node.system{border-color:#8e44ad;background:linear-gradient(135deg,#f8f0ff 0%,#ecdcff 100%)}
    .node.equipment{border-color:#3498db;background:linear-gradient(135deg,#f0f8ff 0%,#d9ecff 100%)}
    .node.point{border-color:#ff6b35;background:linear-gradient(135deg,#fff8f5 0%,#ffe8df 100%)}

    /* Tabs */
    .tabs{display:flex;gap:8px;flex-wrap:wrap;border-bottom:2px solid #eef2f7;padding-bottom:8px;margin-top:10px}
    .tab{appearance:none;border:1px solid #d8e0f2;background:#fff;color:#405a7f;font-weight:600;padding:6px 10px;border-radius:10px;cursor:pointer}
    .tab.active{border-color:var(--brand);color:#0f3b74;box-shadow:0 1px 4px rgba(74,144,226,.25)}
    .diagram-site-title{font-size:22px;font-weight:800;text-align:center;margin:12px 0 6px;color:#263238}
    #flowSection{display:none}
  </style>
  <script src="https://unpkg.com/n3@1.16.2/browser/n3.min.js"></script>
</head>
<body>
  <div class="container">
    <h1>üè¢ Universal Building Model Viewer</h1>
    <div class="subtitle">Load any Turtle (.ttl) file (Brick/REC) and explore it as a friendly UI.</div>

    <div class="uploader">
      <label class="view-toggle" for="flowToggle">
        <input type="checkbox" id="flowToggle" />
        <span class="label">üó∫Ô∏è Diagram</span>
      </label>
      <span class="spacer"></span>
      <label class="btn" for="ttlFile">üìÅ Choose .ttl</label>
      <input id="ttlFile" type="file" accept=".ttl,.txt" />
      <span id="fileMeta" class="badge">No file loaded</span>
      <button id="resetBtn" class="btn secondary">Reset</button>
    </div>

    <div class="breadcrumb" id="breadcrumb">
      <span class="breadcrumb-item" onclick="navigateTo('root')">üè† Home</span>
    </div>

    <div class="statsbar"><span class="badge" id="stats">0 things</span></div>

    <div class="row" style="margin-bottom:10px">
      <div class="current-level" id="currentLevel">Load a .ttl to begin</div>
      <div class="spacer"></div>
      <button id="backButton" class="back-button hidden" onclick="goBack()">‚Üê Back</button>
    </div>

    <div id="sectionHeader" class="section-title"></div>
    <div class="items-grid" id="itemsContainer"></div>

    <div id="flowSection"></div>

    <details style="margin-top:16px">
      <summary>Developer diagnostics</summary>
      <div class="tiny muted">Prefixes, raw entities, and the derived hierarchy can help debug mapping logic.</div>
      <pre id="debug" style="white-space:pre-wrap;background:#fff;padding:10px;border-radius:10px;border:1px solid #eee;max-height:360px;overflow:auto;"></pre>
    </details>
  </div>

  <script>
  // =============== Helpers ===============
  const PRED = { type:'http://www.w3.org/1999/02/22-rdf-syntax-ns#type', label:'http://www.w3.org/2000/01/rdf-schema#label', comment:'http://www.w3.org/2000/01/rdf-schema#comment' };
  const POINT_NAME_HINTS=['Point','Sensor','Setpoint','Command','Status','Alarm','Reading'];
  const EQUIPMENT_NAME_HINTS=['Equipment','Device','Boiler','Chiller','Pump','Fan','AHU','VAV','FCU','Valve','Meter','Heat_Exchanger','Coil','Controller','Thermostat','Heater','Cooler','Filter','Damper','Compressor','Tower','Generator'];
  const BUCKET_KEY=Object.freeze({ campus:'campuses', building:'buildings', space:'spaces', system:'systems', equipment:'equipment', point:'points', unknown:'unknowns' });
  const CONTAIN_RELS=new Set(['hasPart','contains','includes','hasComponent','hasSubComponent','hasSubSystem','hasPoint']);
  const PARTOF_RELS=new Set(['isPartOf','partOf','isIncludedIn','includedIn','componentOfBuilding','componentOfSpace','componentOfLevel','componentOfRoom','componentOf','isComponentOf','isSubSystemOf','isPointOf','pointOf']);
  const LOC_RELS=new Set(['hasLocation','isLocatedIn','locatedIn','location','hasSiteLocation']);
  const localName=(iri)=>{ if(!iri) return iri; const m=String(iri).match(/[\/#]([^\/#]+)$/); return m? m[1] : iri; };
  function toQName(iri,prefixes){ if(!iri||typeof iri!=='string') return iri; for(const [pfx,base] of Object.entries(prefixes||{})){ if(iri.startsWith(base)) return pfx+':'+iri.slice(base.length); } return iri; }

  // =============== Parsing & model derivation ===============
  async function parseTurtleString(turtleText){
    const parser=new N3.Parser(); const quads=[]; const prefixes={};
    await new Promise((resolve,reject)=>{ parser.parse(turtleText,(err,q,pfx)=>{ if(err) reject(err); if(q) quads.push(q); else { Object.assign(prefixes,pfx); resolve(); } }); });

    const E={}; const ensure=(iri)=> E[iri] || (E[iri]={ iri, label:null, comment:null, types:new Set(), props:new Map(), out:[], in:[] });
    for(const q of quads){
      const s=q.subject.termType==='BlankNode'?('_:'+q.subject.value):q.subject.value; const p=q.predicate.value; const o=q.object; const subj=ensure(s); const pLocal=localName(p);
      if(p===PRED.type){ if(o.termType==='NamedNode') subj.types.add(o.value); }
      else if(p===PRED.label){ subj.label=o.termType==='Literal'?o.value:localName(o.value); }
      else if(p===PRED.comment){ subj.comment=o.termType==='Literal'?o.value:String(o.value); }
      else{
        if(!subj.props.has(pLocal)) subj.props.set(pLocal,new Set());
        const val=(o.termType==='Literal')? o.value : (o.termType==='BlankNode'?('_:'+o.value):o.value);
        subj.props.get(pLocal).add(val);
        if(o.termType==='NamedNode'||o.termType==='BlankNode'){
          const oiri=(o.termType==='BlankNode')?('_:'+o.value):o.value; const obj=ensure(oiri);
          subj.out.push({p:pLocal,o:obj.iri}); obj.in.push({p:pLocal,s:subj.iri});
        }
      }
    }

    // subclass tracing
    const SUPER=new Map();
    for(const ent of Object.values(E)) for(const edge of ent.out){ if(edge.p==='subClassOf'){ if(!SUPER.has(ent.iri)) SUPER.set(ent.iri,new Set()); SUPER.get(ent.iri).add(edge.o); } }
    const memo=new Map();
    function supersOf(t){ if(memo.has(t)) return memo.get(t); const seen=new Set(); const st=[t]; while(st.length){ const cur=st.pop(); const ps=SUPER.get(cur); if(ps) for(const p of ps){ if(!seen.has(p)){ seen.add(p); st.push(p); } } } memo.set(t,seen); return seen; }
    function hasTypeOrSubclass(ent, names){ const typeIRIs=[...ent.types]; for(const t of typeIRIs){ const loc=localName(t);
      if(names.some(n=> n.toLowerCase()===loc.toLowerCase())) return true; for(const s of supersOf(t)){ const sLoc=localName(s); if(names.some(n=> n.toLowerCase()===sLoc.toLowerCase())) return true; } }
      return false; }

    function classify(ent){
      const typeLocals=[...ent.types].map(localName);

      // Campus/Site classification
      if(hasTypeOrSubclass(ent,['Campus','Site'])) return {cat:'campus',typename:typeLocals.find(t=>/Campus|Site/i.test(t))||'Campus'};

      // Building classification
      if(hasTypeOrSubclass(ent,['Building'])) return {cat:'building',typename:typeLocals.find(t=>/Building/i.test(t))||'Building'};

      // Point classification - check for sensors, points, and related types first
      if(hasTypeOrSubclass(ent,['Point','Sensor','Setpoint','Command','Status','Alarm','Reading']) ||
         typeLocals.some(t=>/Point|Sensor|Setpoint|Command|Status|Alarm|Reading|Temperature_Sensor|Pressure_Sensor|Flow_Sensor|Zone_Air_Temperature_Sensor/i.test(t))) {
        return {cat:'point',typename:typeLocals.find(t=>/Point|Sensor|Setpoint|Command|Status|Alarm|Reading|Temperature_Sensor|Pressure_Sensor|Flow_Sensor|Zone_Air_Temperature_Sensor/i.test(t))||'Point'};
      }

      // Space classification
      if(hasTypeOrSubclass(ent,['Room','Space','Zone','Area','Level','Storey','Floor','Stairwell']) ||
         typeLocals.some(t=>/Room|Space|Zone|Area|Level|Storey|Floor|Stair/i.test(t))) {
        return {cat:'space',typename:typeLocals.find(t=>/Room|Space|Zone|Area|Level|Storey|Floor|Stair/i.test(t))||'Space'};
      }

      // System classification
      if(hasTypeOrSubclass(ent,['System']) || typeLocals.some(t=>/System/i.test(t))) {
        return {cat:'system',typename:typeLocals.find(t=>/System/i.test(t))||'System'};
      }

      // Equipment classification
      if(hasTypeOrSubclass(ent,['Equipment','Device']) ||
         typeLocals.some(t=>/Equipment|Device|Boiler|Chiller|Pump|Fan|AHU|VAV|FCU|Valve|Meter|Heat_Exchanger|Coil|Controller|Thermostat|Heater|Cooler|Filter|Damper|Compressor|Tower|Generator/i.test(t))) {
        return {cat:'equipment',typename:typeLocals.find(t=>/Equipment|Device|Boiler|Chiller|Pump|Fan|AHU|VAV|FCU|Valve|Meter|Heat_Exchanger|Coil|Controller|Thermostat|Heater|Cooler|Filter|Damper|Compressor|Tower|Generator/i.test(t))||'Equipment'};
      }

      // Check relationships for equipment classification
      if(ent.in.some(e=> CONTAIN_RELS.has(e.p) && /System/i.test(localName(e.s))) || ent.out.some(e=> PARTOF_RELS.has(e.p) && /System/i.test(localName(e.o)))) {
        return {cat:'equipment',typename:typeLocals[0]||'Equipment'};
      }

      // Check location relationships for equipment
      if(ent.out.some(e=> LOC_RELS.has(e.p) && /Room|Space|Zone|Area|Level|Storey|Floor|Stair/i.test(localName(e.o)))) {
        return {cat:'equipment',typename:typeLocals[0]||'Equipment'};
      }

      return {cat:'unknown',typename:typeLocals[0]||'Thing'};
    }

    const buckets={campuses:{},buildings:{},spaces:{},systems:{},equipment:{},points:{},unknowns:{}};
    const addBucket=(cat,iri,item)=>{ const key=BUCKET_KEY[cat]||'unknowns'; if(!buckets[key]) buckets[key]={}; buckets[key][iri]=item; };

    for(const ent of Object.values(E)){
      const {cat,typename}=classify(ent); const label=ent.label || toQName(ent.iri,prefixes) || localName(ent.iri); const base={label,type:typename,_iri:ent.iri};
      if(cat==='campus') addBucket('campus',ent.iri,{...base,buildings:[],systems:[],spaces:[],equipment:[]});
      else if(cat==='building') addBucket('building',ent.iri,{...base,campus:null,spaces:[],systems:[],equipment:[]});
      else if(cat==='space') addBucket('space',ent.iri,{...base,building:null,parentSpace:null,spaces:[],equipment:[],points:[]});
      else if(cat==='system') addBucket('system',ent.iri,{...base,building:null,equipment:[],points:[]});
      else if(cat==='equipment') addBucket('equipment',ent.iri,{...base,space:null,system:null,points:[]});
      else if(cat==='point') addBucket('point',ent.iri,{...base,equipment:null,system:null,space:null});
      else addBucket('unknown',ent.iri,base);
    }

    function linkCampusBuilding(c,b){ if(!c||!b) return; c.buildings.push(b._iri); b.campus=b.campus||c._iri; }
    function linkCampusSystem(c,s){ if(!c||!s) return; c.systems.push(s._iri); }
    function linkCampusSpace(c,r){ if(!c||!r) return; c.spaces.push(r._iri); }
    function linkCampusEquipment(c,e){ if(!c||!e) return; c.equipment.push(e._iri); }
    function linkBuildingSpace(b,r){ if(!b||!r) return; b.spaces.push(r._iri); r.building=r.building||b._iri; }
    function linkBuildingSystem(b,s){ if(!b||!s) return; b.systems.push(s._iri); s.building=s.building||b._iri; }
    function linkBuildingEquipment(b,e){ if(!b||!e) return; b.equipment.push(e._iri); }
    function linkSpaceSpace(parent,child){ if(!parent||!child) return; parent.spaces.push(child._iri); child.parentSpace=child.parentSpace||parent._iri; }
    function linkSpaceEquipment(r,e){ if(!r||!e) return; r.equipment.push(e._iri); e.space=e.space||r._iri; }
    function linkSystemEquipment(s,e){ if(!s||!e) return; s.equipment.push(e._iri); e.system=e.system||s._iri; }
    function linkEquipmentPoint(eq,p){ if(!eq||!p) return; eq.points.push(p._iri); p.equipment=p.equipment||eq._iri; }
    function linkSystemPoint(s,p){ if(!s||!p||p.equipment) return; s.points.push(p._iri); p.system=p.system||s._iri; }
    function linkSpacePoint(r,p){ if(!r||!p||p.equipment||p.system) return; r.points.push(p._iri); p.space=p.space||r._iri; }

    for(const ent of Object.values(E)){
      for(const edge of ent.out){
        const sIRI=ent.iri, oIRI=edge.o, p=edge.p;
        const sC=buckets.campuses[sIRI], sB=buckets.buildings[sIRI], sR=buckets.spaces[sIRI], sSys=buckets.systems[sIRI], sEq=buckets.equipment[sIRI], sPt=buckets.points[sIRI];
        const oC=buckets.campuses[oIRI], oB=buckets.buildings[oIRI], oR=buckets.spaces[oIRI], oS=buckets.systems[oIRI], oE=buckets.equipment[oIRI], oPt=buckets.points[oIRI];
        if(CONTAIN_RELS.has(p)){
          if(sC&&oB) linkCampusBuilding(sC,oB); if(sC&&oS) linkCampusSystem(sC,oS); if(sC&&oR) linkCampusSpace(sC,oR); if(sC&&oE) linkCampusEquipment(sC,oE);
          if(sB&&oR) linkBuildingSpace(sB,oR); if(sB&&oS) linkBuildingSystem(sB,oS); if(sB&&oE) linkBuildingEquipment(sB,oE);
          if(sR&&oE) linkSpaceEquipment(sR,oE); if(sSys&&oE) linkSystemEquipment(sSys,oE);
          if(sR&&oR) linkSpaceSpace(sR,oR);
          if(sEq&&oPt) linkEquipmentPoint(sEq,oPt);
          if(sSys&&oPt) linkSystemPoint(sSys,oPt);
          if(sR&&oPt) linkSpacePoint(sR,oPt);
        }
        if(PARTOF_RELS.has(p)){
          if(sB&&oC) linkCampusBuilding(oC,sB); if(sSys&&oC) linkCampusSystem(oC,sSys); if(sR&&oC) linkCampusSpace(oC,sR); if(sEq&&oC) linkCampusEquipment(oC,sEq);
          if(sR&&oB) linkBuildingSpace(oB,sR); if(sSys&&oB) linkBuildingSystem(oB,sSys); if(sEq&&oB) linkBuildingEquipment(oB,sEq);
          if(sEq&&oS) linkSystemEquipment(oS,sEq);
          if(sR&&oR) linkSpaceSpace(oR,sR);
          if(sPt&&oE) linkEquipmentPoint(oE,sPt);
          if(sPt&&oS) linkSystemPoint(oS,sPt);
          if(sPt&&oR) linkSpacePoint(oR,sPt);
        }
        if(LOC_RELS.has(p)){
          if(sEq&&oR) linkSpaceEquipment(oR,sEq);
          if(sR&&oB) linkBuildingSpace(oB,sR);
          if(sSys&&oB) linkBuildingSystem(oB,sSys);
          if(sR&&oR) linkSpaceSpace(oR,sR);
          if(sPt&&oR) linkSpacePoint(oR,sPt);
        }
      }
    }

    // Post-processing: Find most granular parent for orphaned points
    for(const point of Object.values(buckets.points)){
      if(!point.equipment){
        // Find most granular system or space this point should belong to
        let bestSystem = null;
        let bestSpace = null;

        // Check all systems to find the most specific one that should contain this point
        for(const sys of Object.values(buckets.systems)){
          // Check if point is related to equipment in this system
          const relatedEquipment = (sys.equipment || []).some(eqId => {
            const eq = buckets.equipment[eqId];
            return eq && (eq.space === point.space ||
                         // Check if point and equipment share location context
                         (eq.space && point.space &&
                          buckets.spaces[eq.space] && buckets.spaces[point.space] &&
                          (buckets.spaces[eq.space].building === buckets.spaces[point.space].building ||
                           buckets.spaces[eq.space].parentSpace === buckets.spaces[point.space].parentSpace)));
          });

          if(relatedEquipment ||
             // Or if point is directly related to system through relationships
             (point.system === sys._iri) ||
             // Or if system and point share same building/space context
             (sys.building && point.space && buckets.spaces[point.space] &&
              buckets.spaces[point.space].building === sys.building)){
            if(!bestSystem || (sys.equipment && sys.equipment.length < (bestSystem.equipment?.length || 0))){
              bestSystem = sys;
            }
          }
        }

        // Find most granular space
        if(point.space){
          bestSpace = buckets.spaces[point.space];
          // Look for more granular child spaces
          const findMostGranularSpace = (spaceId) => {
            const space = buckets.spaces[spaceId];
            if(!space) return null;

            // Find child spaces that might be more appropriate
            const childSpaces = (space.spaces || []).filter(childId => {
              const child = buckets.spaces[childId];
              return child && (child.equipment || []).length > 0;
            });

            if(childSpaces.length === 1){
              return findMostGranularSpace(childSpaces[0]) || buckets.spaces[childSpaces[0]];
            }
            return space;
          };
          bestSpace = findMostGranularSpace(point.space) || bestSpace;
        }

        // Assign to most appropriate parent (prefer system if it's more specific)
        if(bestSystem && (!bestSpace || (bestSystem.equipment && bestSystem.equipment.length > 0))){
          if(!point.system){
            linkSystemPoint(bestSystem, point);
          }
        } else if(bestSpace && !point.space){
          linkSpacePoint(bestSpace, point);
        }
      }
    }

    // Clean up: Remove points from spaces/systems if they have equipment parents
    for(const point of Object.values(buckets.points)){
      if(point.equipment){
        // Remove this point from any spaces that might contain it
        for(const space of Object.values(buckets.spaces)){
          const idx = (space.points || []).indexOf(point._iri);
          if(idx !== -1){
            space.points.splice(idx, 1);
          }
        }
        // Remove this point from any systems that might contain it
        for(const system of Object.values(buckets.systems)){
          const idx = (system.points || []).indexOf(point._iri);
          if(idx !== -1){
            system.points.splice(idx, 1);
          }
        }
      }
    }

    // Orphans & synthetic site
    const systemsLinkedToCampus=new Set(); for(const c of Object.values(buckets.campuses)) for(const sid of (c.systems||[])) systemsLinkedToCampus.add(sid);
    const orphanBuildings=Object.entries(buckets.buildings).filter(([,b])=>!b.campus).map(([id])=>id);
    const orphanSpaces=Object.entries(buckets.spaces).filter(([,r])=> !r.building && !r.parentSpace && !Object.values(buckets.campuses).some(c=> (c.spaces||[]).includes(r._iri))).map(([id])=>id);
    const orphanSystems=Object.entries(buckets.systems).filter(([,s])=> !s.building && !systemsLinkedToCampus.has(s._iri)).map(([id])=>id);
    const orphanEquipment=Object.entries(buckets.equipment).filter(([,e])=> !e.space && !e.system && !Object.values(buckets.buildings).some(b=> (b.equipment||[]).includes(e._iri)) && !Object.values(buckets.campuses).some(c=> (c.equipment||[]).includes(e._iri))).map(([id])=>id);
    const orphanPoints=Object.entries(buckets.points).filter(([,p])=> !p.equipment && !p.system && !p.space).map(([id])=>id);

    if(Object.keys(buckets.campuses).length===0 && Object.keys(buckets.buildings).length>0){
      const syntheticIRI='urn:synthetic:campus:default';
      buckets.campuses[syntheticIRI]={label:'Site',type:'Campus',_iri:syntheticIRI,buildings:[],systems:[],spaces:[],equipment:[]};
      for(const id of Object.keys(buckets.buildings)) buckets.campuses[syntheticIRI].buildings.push(id);
    }

    const tidy=(arr)=> Array.from(new Set((arr||[]).filter(Boolean)));
    for(const c of Object.values(buckets.campuses)){ c.buildings=tidy(c.buildings); c.systems=tidy(c.systems).filter(id=>!(buckets.systems[id]&&buckets.systems[id].building)); c.spaces=tidy(c.spaces); c.equipment=tidy(c.equipment); }
    for(const b of Object.values(buckets.buildings)){ b.spaces=tidy(b.spaces); b.systems=tidy(b.systems); b.equipment=tidy(b.equipment); }
    for(const r of Object.values(buckets.spaces)){ r.spaces=tidy(r.spaces); r.equipment=tidy(r.equipment); r.points=tidy(r.points); }
    for(const s of Object.values(buckets.systems)){ s.equipment=tidy(s.equipment); s.points=tidy(s.points); }
    for(const e of Object.values(buckets.equipment)){ e.points=tidy(e.points); }

    const data={...buckets, orphanBuildings, orphanSpaces, orphanSystems, orphanEquipment, orphanPoints};
    const stats={ prefixes, counts:{ campuses:Object.keys(buckets.campuses).length, buildings:Object.keys(buckets.buildings).length, spaces:Object.keys(buckets.spaces).length, systems:Object.keys(buckets.systems).length, equipment:Object.keys(buckets.equipment).length, points:Object.keys(buckets.points).length, entities:Object.keys(E).length, unknowns:Object.keys(buckets.unknowns).length, orphanBuildings:orphanBuildings.length, orphanSpaces:orphanSpaces.length, orphanSystems:orphanSystems.length, orphanEquipment:orphanEquipment.length, orphanPoints:orphanPoints.length }, entities:E };
    return { data, stats, prefixes };
  }

  // =============== UI state & navigation ===============
  let MODEL=null; let currentPath=['root']; let historyStack=[{level:'root',data:null}]; let SELECTED_CAMPUS_ID=null;
  function escapeHtml(s){ return (s==null?'':String(s)).replace(/[&<>"']/g, ch=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch])); }

  function updateBreadcrumb(){
    const el=document.getElementById('breadcrumb');
    el.innerHTML='<span class="breadcrumb-item" onclick="navigateTo(\'root\')">üè† Home</span>';
    for(let i=1;i<currentPath.length;i++){
      const id=currentPath[i]; const item=getItemById(id);
      if(item){ el.innerHTML += '<span class="breadcrumb-separator">‚Ä∫</span>' + `<span class="breadcrumb-item" onclick="navigateToPath(${i})">${escapeHtml(item.label)}</span>`; }
    }
  }

  function getItemById(id){ const d=MODEL?.data; if(!d) return null; if(id==='__loose__'){ return { _iri:'__loose__', label:'Loose Items', type:'Loose', spaces:(d.orphanSpaces||[]).slice(), systems:(d.orphanSystems||[]).slice(), equipment:(d.orphanEquipment||[]).slice(), points:(d.orphanPoints||[]).slice() }; } return d.campuses[id]||d.buildings[id]||d.spaces[id]||d.systems[id]||d.equipment[id]||d.points?.[id]||null; }
  function getItemType(id){ const d=MODEL?.data; if(id==='__loose__') return 'loose'; if(!d) return 'unknown'; if(d.campuses[id]) return 'campus'; if(d.buildings[id]) return 'building'; if(d.spaces[id]) return 'space'; if(d.systems[id]) return 'system'; if(d.equipment[id]) return 'equipment'; if(d.points && d.points[id]) return 'point'; return 'unknown'; }

  function navigateTo(level,itemId=null){ if(level==='root'){ currentPath=['root']; historyStack=[{level:'root',data:null}]; } else { currentPath.push(itemId); historyStack.push({level,data:itemId}); } updateView(); if(document.getElementById('flowToggle').checked) renderFlowchart(); }
  function navigateToPath(index){ currentPath=currentPath.slice(0,index+1); historyStack=historyStack.slice(0,index+1); updateView(); if(document.getElementById('flowToggle').checked) renderFlowchart(); }
  function goBack(){ if(currentPath.length>1){ currentPath.pop(); historyStack.pop(); updateView(); if(document.getElementById('flowToggle').checked) renderFlowchart(); } }

  function createItemCard(id,item,type){
    const card=document.createElement('div'); card.className=`item-card tag-${type}`; card.onclick=()=>navigateTo(type,id);
    let details=`Type: ${escapeHtml(item.type)}`; let locationInfo=''; let count=0;
    if(type==='campus'){
      const bC=item.buildings?.length||0;
      const sC=(item.systems||[]).filter(sid=> !MODEL?.data?.systems?.[sid]?.building).length;
      const rC=item.spaces?.length||0; const eC=item.equipment?.length||0; count=bC+sC+rC+eC;
      details+=`<br>Buildings: ${bC}, Systems: ${sC}, Spaces: ${rC}, Equipment: ${eC}`;
    } else if(type==='building'){
      const rc=item.spaces?.length||0; const sc=item.systems?.length||0; const ec=item.equipment?.length||0; count=rc+sc+ec;
      details+=`<br>Spaces: ${rc}, Systems: ${sc}, Equipment: ${ec}`;
      const campus=MODEL?.data?.campuses?.[item.campus]; if(campus) locationInfo=`<div class="location-info">üìç Campus: ${escapeHtml(campus.label)}</div>`;
    } else if(type==='loose'){
      const rc=MODEL?.data?.orphanSpaces?.length||0; const sc=MODEL?.data?.orphanSystems?.length||0; const ec=MODEL?.data?.orphanEquipment?.length||0; const pc=MODEL?.data?.orphanPoints?.length||0; count=rc+sc+ec+pc;
      details+=`<br>Spaces: ${rc}, Systems: ${sc}, Equipment: ${ec}, Points: ${pc}`;
    } else if(type==='space'){
      const sub=item.spaces?.length||0; const eq=item.equipment?.length||0; const pt=item.points?.length||0; count=sub+eq+pt;
      details+=`<br>Spaces: ${sub}, Equipment: ${eq}, Points: ${pt}`;
      const parentS=MODEL?.data?.spaces?.[item.parentSpace]; const b=MODEL?.data?.buildings?.[item.building];
      if(parentS) locationInfo=`<div class=\"location-info\">üß≠ Parent Space: ${escapeHtml(parentS.label)}</div>`; else if(b) locationInfo=`<div class=\"location-info\">üè¢ Building: ${escapeHtml(b.label)}</div>`;
    } else if(type==='system'){
      const pt=item.points?.length||0; count=(item.equipment?.length||0)+pt; details+=`<br>Equipment: ${item.equipment?.length||0}, Points: ${pt}`;
      const b=MODEL?.data?.buildings?.[item.building]; if(b) locationInfo=`<div class=\"location-info\">üè¢ Building: ${escapeHtml(b.label)}</div>`;
    } else if(type==='equipment'){
      const pt=item.points?.length||0; count=pt; details+=`<br>Points: ${pt}`;
      const space=MODEL?.data?.spaces?.[item.space]; const sys=MODEL?.data?.systems?.[item.system];
      locationInfo=`<div class=\"location-info\">üìç Space: ${escapeHtml(space?.label||'-')}<br>üîß System: ${escapeHtml(sys?.label||'-')}</div>`;
    } else if(type==='point'){
      // Infer missing fields from equipment/system/space relationships
      let eq=item.equipment ? MODEL?.data?.equipment?.[item.equipment] : null;
      let sys=item.system ? MODEL?.data?.systems?.[item.system] : null;
      let sp=item.space ? MODEL?.data?.spaces?.[item.space] : null;
      if(!sys && eq && eq.system){ sys = MODEL?.data?.systems?.[eq.system]; }
      if(!sp && eq && eq.space){ sp = MODEL?.data?.spaces?.[eq.space]; }
      locationInfo=`<div class=\"location-info\">üîå Equipment: ${escapeHtml(eq?.label||'-')}<br>üß© System: ${escapeHtml(sys?.label||'-')}<br>üìç Space: ${escapeHtml(sp?.label||'-')}</div>`;
    }
    card.innerHTML=`<div class=\"item-title\">${escapeHtml(item.label)}</div><div class=\"item-type\"><span class=\"badge\">${escapeHtml(item.type)}</span></div><div class=\"item-details\">${details}</div>${locationInfo}${count>0?`<div class=\"item-count\">${count}</div>`:''}`;
    return card;
  }

  function updateView(){
    const container=document.getElementById('itemsContainer'); const levelEl=document.getElementById('currentLevel'); const backBtn=document.getElementById('backButton'); const stats=document.getElementById('stats'); const header=document.getElementById('sectionHeader');
    const flow=document.getElementById('flowToggle').checked;

    if(!MODEL){ container.innerHTML='<div class="no-items">No model loaded yet.</div>'; header.textContent=''; levelEl.textContent='Load a .ttl to begin'; backBtn.classList.add('hidden'); updateBreadcrumb(); stats.textContent='0 things'; document.getElementById('debug').textContent=''; document.getElementById('flowSection').innerHTML=''; return; }

    stats.textContent=`${MODEL.stats.counts.entities} entities ‚Ä¢ ${MODEL.stats.counts.campuses} campuses ‚Ä¢ ${MODEL.stats.counts.buildings} buildings ‚Ä¢ ${MODEL.stats.counts.spaces} spaces ‚Ä¢ ${MODEL.stats.counts.systems} systems ‚Ä¢ ${MODEL.stats.counts.equipment} equipment ‚Ä¢ ${MODEL.stats.counts.points} points`;

    document.getElementById('flowSection').style.display = flow? 'block':'none';
    document.getElementById('itemsContainer').style.display = flow? 'none':'grid';
    document.getElementById('sectionHeader').style.display = flow? 'none':'';
    document.getElementById('breadcrumb').style.display = flow? 'none':'';
    backBtn.classList.toggle('hidden', flow || currentPath.length===1);
    levelEl.textContent = flow? '' : (currentPath.length===1 ? 'Home' : (getItemById(currentPath[currentPath.length-1])?.label||''));

    if(flow){ renderFlowchart(); return; }

    container.innerHTML='';
    const atRoot=currentPath.length===1;
    if(atRoot){
      header.textContent='Campuses & Loose Items';
      const elements=[];
      for(const [id,item] of Object.entries(MODEL.data.campuses)) elements.push(createItemCard(id,item,'campus'));
      for(const id of MODEL.data.orphanBuildings) elements.push(createItemCard(id, MODEL.data.buildings[id], 'building'));
      const hasLoose=((MODEL.data.orphanSpaces||[]).length + (MODEL.data.orphanSystems||[]).length + (MODEL.data.orphanEquipment||[]).length + (MODEL.data.orphanPoints||[]).length) > 0;
      if(hasLoose) elements.push(createItemCard('__loose__', { label:'Loose Items', type:'Loose' }, 'loose'));
      if(elements.length===0) container.innerHTML='<div class="no-items">No items detected.</div>'; else elements.forEach(el=>container.appendChild(el));
    } else {
      const currentId=currentPath[currentPath.length-1]; const currentItem=getItemById(currentId); const currentType=getItemType(currentId);
      if(currentType==='campus'){
        header.textContent='Buildings ‚Ä¢ Spaces ‚Ä¢ Systems ‚Ä¢ Equipment';
        const rows=[];
        (currentItem.buildings||[]).forEach(bid=>{ const b=MODEL.data.buildings[bid]; if(b) rows.push(['building',bid,b]); });
        (currentItem.spaces||[]).forEach(rid=>{ const r=MODEL.data.spaces[rid]; if(r) rows.push(['space',rid,r]); });
        (currentItem.systems||[]).forEach(sid=>{ const s=MODEL.data.systems[sid]; if(s && !s.building) rows.push(['system',sid,s]); });
        (currentItem.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(e) rows.push(['equipment',eid,e]); });
        if(rows.length===0) container.innerHTML='<div class="no-items">No items linked to this campus.</div>'; else rows.forEach(([t,id,o])=> container.appendChild(createItemCard(id,o,t)));
      } else if(currentType==='building'){
        header.textContent='Spaces ‚Ä¢ Systems ‚Ä¢ Equipment';
        const rows=[];
        (currentItem.spaces||[]).forEach(rid=>{ const r=MODEL.data.spaces[rid]; if(r) rows.push(['space',rid,r]); });
        (currentItem.systems||[]).forEach(sid=>{ const s=MODEL.data.systems[sid]; if(s) rows.push(['system',sid,s]); });
        (currentItem.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(e) rows.push(['equipment',eid,e]); });
        if(rows.length===0) container.innerHTML='<div class="no-items">No items linked to this building.</div>'; else rows.forEach(([t,id,o])=> container.appendChild(createItemCard(id,o,t)));
      } else if(currentType==='loose'){
        header.textContent='Loose Items';
        const rows=[]; const loose=getItemById('__loose__');
        (loose.spaces||[]).forEach(rid=>{ const r=MODEL.data.spaces[rid]; if(r) rows.push(['space',rid,r]); });
        (loose.systems||[]).forEach(sid=>{ const s=MODEL.data.systems[sid]; if(s) rows.push(['system',sid,s]); });
        (loose.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(e) rows.push(['equipment',eid,e]); });
        (loose.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p) rows.push(['point',pid,p]); });
        if(rows.length===0) container.innerHTML='<div class="no-items">No loose items.</div>'; else rows.forEach(([t,id,o])=> container.appendChild(createItemCard(id,o,t)));
      } else if(currentType==='space'){
        header.textContent='';
        const rows=[];
        (currentItem.spaces||[]).forEach(cid=>{ const c=MODEL.data.spaces[cid]; if(c) rows.push(['space',cid,c]); });
        (currentItem.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(e) rows.push(['equipment',eid,e]); });
        // Only show points that don't have equipment parents
        (currentItem.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p && !p.equipment) rows.push(['point',pid,p]); });
        if(rows.length===0) container.innerHTML='<div class="no-items">No items found under this space.</div>'; else rows.forEach(([t,id,o])=> container.appendChild(createItemCard(id,o,t)));
      } else if(currentType==='system'){
        header.textContent='Equipment ‚Ä¢ Points';
        const rows=[];
        (currentItem.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(e) rows.push(['equipment',eid,e]); });
        // Only show points that don't have equipment parents
        (currentItem.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p && !p.equipment) rows.push(['point',pid,p]); });
        if(rows.length===0) container.innerHTML='<div class="no-items">No equipment or points.</div>'; else rows.forEach(([t,id,o])=> container.appendChild(createItemCard(id,o,t)));
      } else if(currentType==='equipment'){
        header.textContent='Points';
        const rows=[];
        (currentItem.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p) rows.push(['point',pid,p]); });
        if(rows.length===0){
          container.appendChild(createItemCard(currentId,currentItem,'equipment'));
        } else rows.forEach(([t,id,o])=> container.appendChild(createItemCard(id,o,t)));
      } else if(currentType==='point'){
        header.textContent='Point Details';
        container.innerHTML='';
        const e = currentItem;
        // Infer fields again for the details view
        let eq=e.equipment ? MODEL?.data?.equipment?.[e.equipment] : null;
        let sys=e.system ? MODEL?.data?.systems?.[e.system] : null;
        let sp=e.space ? MODEL?.data?.spaces?.[e.space] : null;
        if(!sys && eq && eq.system) sys = MODEL.data.systems[eq.system];
        if(!sp && eq && eq.space) sp = MODEL.data.spaces[eq.space];
        const card=document.createElement('div'); card.className='item-card tag-point';
        const iriHtml = `<div class=\"tiny muted\" style=\"margin-top:6px\">IRI: ${escapeHtml(e._iri)}</div>`;
        const meta = `<div class=\"location-info\">üîå Equipment: ${escapeHtml(eq?.label||'-')}<br>üß© System: ${escapeHtml(sys?.label||'-')}<br>üìç Space: ${escapeHtml(sp?.label||'-')}</div>`;
        // Show a few known properties if we have them
        let propsHtml='';
        try {
          const raw = MODEL?.stats?.entities?.[e._iri];
          if(raw && raw.props){
            const entries = Array.from(raw.props.entries()).slice(0,12);
            if(entries.length){
              propsHtml = `<div class=\"section-title\" style=\"margin-top:10px\">Properties</div><ul class=\"tiny\">${entries.map(([k,vs])=>`<li><strong>${escapeHtml(k)}</strong>: ${escapeHtml(Array.from(vs).join(', '))}</li>`).join('')}</ul>`;
            }
          }
        } catch(_) {}
        card.innerHTML = `<div class=\"item-title\">${escapeHtml(e.label)}</div><div class=\"item-type\"><span class=\"badge\">${escapeHtml(e.type)}</span></div>${iriHtml}${meta}${propsHtml}`;
        container.appendChild(card);
      }
    }
    updateBreadcrumb();
  }

  // =============== Flowchart rendering ===============
  function makeNode(cls,title,subtype,location,onClick){
    const el=document.createElement('div'); el.className=`node ${cls}`;
    el.innerHTML=`<div class=\"node-title\">${escapeHtml(title)}</div>${subtype?`<div class=\"node-type\">${escapeHtml(subtype)}</div>`:''}${location?`<div class=\"node-location\">${escapeHtml(location)}</div>`:''}`;
    if(onClick) el.onclick=()=>{ const t=document.getElementById('flowToggle'); if(t&&t.checked){ t.checked=false; } onClick(); };
    return el;
  }

  function renderFlowchart(){
    const root=document.getElementById('flowSection'); root.innerHTML='';
    if(!MODEL){ root.innerHTML='<div class="no-items">No model loaded yet.</div>'; return; }

    // Build tabs: campuses + one tab per orphan building + Loose Items (incl. orphan points)
    const campuses=Object.values(MODEL.data.campuses); let campusList=campuses.slice();
    (MODEL.data.orphanBuildings||[]).forEach(bid=>{ const b=MODEL.data.buildings[bid]; if(b) campusList.push({ label:b.label, _iri:`urn:synthetic:orphan-building:${bid}`, buildings:[bid], synthetic:'building' }); });
    const hasLoose=((MODEL.data.orphanSpaces||[]).length + (MODEL.data.orphanSystems||[]).length + (MODEL.data.orphanEquipment||[]).length + (MODEL.data.orphanPoints||[]).length) > 0;
    if(hasLoose) campusList.push({ label:'Loose Items', _iri:'urn:synthetic:loose', loose:true, buildings:[], systems:(MODEL.data.orphanSystems||[]).slice(), spaces:(MODEL.data.orphanSpaces||[]).slice(), equipment:(MODEL.data.orphanEquipment||[]).slice(), points:(MODEL.data.orphanPoints||[]).slice() });
    if(campusList.length===0) campusList=[{ label:'Site', _iri:'urn:synthetic:campus:default', buildings:Object.keys(MODEL.data.buildings) }];

    // Tabs
    const tabs=document.createElement('div'); tabs.className='tabs';
    campusList.forEach(c=>{ const btn=document.createElement('button'); btn.className='tab'+(c._iri===SELECTED_CAMPUS_ID?' active':''); btn.textContent=c.label||'Campus'; btn.onclick=()=>{ SELECTED_CAMPUS_ID=c._iri; renderFlowchart(); }; tabs.appendChild(btn); });
    root.appendChild(tabs);

    // Active campus/site
    let campus=campusList[0]||null; const found=SELECTED_CAMPUS_ID? campusList.find(c=>c._iri===SELECTED_CAMPUS_ID):null; if(found){ campus=found; } else if(campus){ SELECTED_CAMPUS_ID=campus._iri; }
    if(!campus){ root.innerHTML+='<div class="no-items">No campus/site to show.</div>'; return; }

    // Title
    const title=document.createElement('div'); title.className='diagram-site-title'; title.textContent=campus.label||'Site'; root.appendChild(title);

    // Diagram wrapper
    const wrap=document.createElement('div'); wrap.className='diagram';

    // Campus bubble (skip for orphan-building-as-site and for Loose Items)
    if(campus.synthetic!=='building' && !campus.loose){ const lvlCampus=document.createElement('div'); lvlCampus.className='level'; lvlCampus.appendChild(makeNode('campus', campus.label||'Campus', 'Campus', null, ()=>navigateTo('campus', campus._iri))); wrap.appendChild(lvlCampus); wrap.appendChild(Object.assign(document.createElement('div'),{className:'connection-line'})); }

    // Buildings & Spaces (with points nested under spaces when not bound to equipment/system)
    const titleBR=document.createElement('div'); titleBR.className='section-title'; titleBR.textContent='Buildings & Spaces'; wrap.appendChild(titleBR);
    const lvlBR=document.createElement('div'); lvlBR.className='level';
    const buildings=(campus.buildings||[]).map(id=>MODEL.data.buildings[id]).filter(Boolean);
    for(const b of buildings){
      const g=document.createElement('div'); g.className='building-group';
      g.appendChild(makeNode('building', b.label, b.type, null, ()=>navigateTo('building', b._iri)));
      const roomsRow=document.createElement('div'); roomsRow.className='rooms-row';
      const childSpaces=(b.spaces||[]).map(id=>MODEL.data.spaces[id]).filter(Boolean).filter(s=>!s.parentSpace);
      for(const r of childSpaces){
        const block=document.createElement('div'); block.style.display='flex'; block.style.flexDirection='column'; block.style.alignItems='center'; block.style.gap='6px';
        block.appendChild(makeNode('room', r.label, r.type, null, ()=>navigateTo('space', r._iri)));
        const pr=document.createElement('div'); pr.className='points-row';
        // Only show points that don't have equipment or system parents
        (r.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p && !p.equipment && !p.system) pr.appendChild(makeNode('point', p.label, p.type, '', ()=>navigateTo('point', p._iri))); });
        if(pr.children.length) block.appendChild(pr);
        roomsRow.appendChild(block);
      }
      if(childSpaces.length) g.appendChild(roomsRow);
      lvlBR.appendChild(g);
    }
    if(campus.loose){
      const looseSpaces=(campus.spaces||[]).map(id=>MODEL.data.spaces[id]).filter(Boolean).filter(s=>!s.parentSpace);
      if(looseSpaces.length){ const row=document.createElement('div'); row.className='rooms-row';
        looseSpaces.forEach(r=>{ const block=document.createElement('div'); block.style.display='flex'; block.style.flexDirection='column'; block.style.alignItems='center'; block.style.gap='6px'; block.appendChild(makeNode('room', r.label, r.type, null, ()=>navigateTo('space', r._iri))); const pr=document.createElement('div'); pr.className='points-row';
        // Only show points that don't have equipment or system parents
        (r.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p && !p.equipment && !p.system) pr.appendChild(makeNode('point', p.label, p.type, '', ()=>navigateTo('point', p._iri))); }); if(pr.children.length) block.appendChild(pr); row.appendChild(block); });
        lvlBR.appendChild(row);
      }
    }
    wrap.appendChild(lvlBR);

    // Systems & Equipment
    const sysTitle=document.createElement('div'); sysTitle.className='section-title'; sysTitle.textContent='Systems & Equipment'; wrap.appendChild(sysTitle);
    const sysGrid=document.createElement('div'); sysGrid.className='systems-grid';
    const campusSystemIds=new Set(); (campus.systems||[]).forEach(id=>campusSystemIds.add(id)); buildings.forEach(b=> (b.systems||[]).forEach(id=>campusSystemIds.add(id)));
    campusSystemIds.forEach(sid=>{ const s=MODEL.data.systems[sid]; if(!s) return; const b=s.building? MODEL.data.buildings[s.building]:null; const loc=b? `üìç Building: ${b.label}`:'üìç Campus-level'; const sg=document.createElement('div'); sg.className='system-group'; sg.appendChild(makeNode('system', s.label, s.type, loc, ()=>navigateTo('system', s._iri))); const eqRow=document.createElement('div'); eqRow.className='equipment-row'; let cnt=0; (s.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(!e) return; const sp=e.space? MODEL.data.spaces[e.space]:null; const showLoc= sp? `üìç Space: ${sp.label}` : (b? `üìç Building: ${b.label}` : ''); eqRow.appendChild(makeNode('equipment', e.label, e.type, showLoc, ()=>navigateTo('equipment', e._iri))); cnt++; }); if(cnt>0) sg.appendChild(eqRow);
    // Only show points that don't have equipment parents
    const sysPts=(s.points||[]).map(pid=> MODEL.data.points?.[pid]).filter(p=>p && !p.equipment); if(sysPts.length){ const pr=document.createElement('div'); pr.className='points-row'; sysPts.forEach(p=> pr.appendChild(makeNode('point', p.label, p.type, '', ()=>navigateTo('point', p._iri)))); sg.appendChild(pr); } sysGrid.appendChild(sg); });

    if(campus.loose && (campus.equipment||[]).length){ const sg=document.createElement('div'); sg.className='system-group'; const eqRow=document.createElement('div'); eqRow.className='equipment-row'; (campus.equipment||[]).forEach(eid=>{ const e=MODEL.data.equipment[eid]; if(!e) return; eqRow.appendChild(makeNode('equipment', e.label, e.type, '', ()=>navigateTo('equipment', e._iri))); }); sg.appendChild(eqRow); sysGrid.appendChild(sg); }
    if(campus.loose && (campus.points||[]).length){ const pr=document.createElement('div'); pr.className='points-row'; (campus.points||[]).forEach(pid=>{ const p=MODEL.data.points?.[pid]; if(p) pr.appendChild(makeNode('point', p.label, p.type, '', ()=>navigateTo('point', p._iri))); }); sysGrid.appendChild(pr); }
    wrap.appendChild(sysGrid);

    root.appendChild(wrap);
  }

  // =============== File input + toggles ===============
  const input=document.getElementById('ttlFile');
  input.addEventListener('change', async (e)=>{
    const file=e.target.files && e.target.files[0]; if(!file) return;
    document.getElementById('fileMeta').textContent = `${file.name} ‚Ä¢ ${Math.round(file.size/1024)} KB`;
    const txt = await file.text();
    try{
      MODEL = await parseTurtleString(txt);
      currentPath=['root']; historyStack=[{level:'root',data:null}]; SELECTED_CAMPUS_ID=null;
      updateView();
      const sample = Object.values(MODEL.stats.entities)[0];
      document.getElementById('debug').textContent = JSON.stringify({ prefixes: MODEL.stats.prefixes || MODEL.prefixes, counts: MODEL.stats.counts, sampleEntity: sample }, null, 2);
    }catch(err){ console.error(err); alert('Parse error: '+err.message); }
  });

  document.getElementById('resetBtn').addEventListener('click', ()=>{ MODEL=null; input.value=''; document.getElementById('fileMeta').textContent='No file loaded'; document.getElementById('flowSection').innerHTML=''; SELECTED_CAMPUS_ID=null; updateView(); });
  document.getElementById('flowToggle').addEventListener('change', ()=>{ SELECTED_CAMPUS_ID=null; updateView(); });

  // Initial render
  updateView();
  </script>
</body>
</html>
